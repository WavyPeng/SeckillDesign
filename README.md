## 秒杀接口设计与实现
>模拟秒杀场景，设计实现一个秒杀接口，应对高并发场景提出一些优化解决方案。

在设计秒杀接口时，主要需要考虑两个问题：
- 如何解决超卖问题？
- 如何尽可能地减少数据库的访问压力？

### 超卖问题
对于超卖问题，其产生的原因如下：

当多线程访问时，假设当前商品库存还有一个，同时过来两个线程，A线程判断商品数大于0，B线程也判断商品数大于0，则两个线程都继续向下执行。若正巧都秒杀到，则执行减库存下订单操作就将库存减成负数了。

超卖问题如何解决呢？

- 情况一：一个用户同时发出多个请求，如果库存足够，未加限制，用户可以下多个订单。
>解决：前端加验证码，防止用户同时发出多个请求。在后端的`seckill_order`表中，对`user_id`和`goods_id`加唯一索引，确保一个用户对一个商品绝不生成两个订单。

- 情况二：减库存的SQL上没有添加库存数量的判断，并发时也会将库存减成负数。
>解决：减库存的SQL上添加库存数量的判断:
```
update t_seckill_goods 
set stock_count = stock_count - 1 
where goods_id = #{goodsId} and stock_count > 0
```

### 高并发问题
秒杀业务的特点在于瞬间的并发量非常大，同时它也是一种读多写少的场景，往往采用`缓存`和`异步化`的方式来解决。主要考虑以下几点：
- 尽量将请求过滤在上游
- 尽可能地利用缓存
- 异步下单增加吞吐量

对于此项目而言，其秒杀流程如下图所示：
![秒杀流程]()

部分功能的具体实现细节如下：
